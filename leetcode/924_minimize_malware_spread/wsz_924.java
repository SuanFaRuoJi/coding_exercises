import java.util.Arrays;
import java.util.Stack;

public class wsz_924 {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int[] uptree = new int[graph.length], cross = new int[graph.length];
        Arrays.fill(uptree, -1);
        Stack<int[]> dfs = new Stack<>();
        for (int i : initial) {
            uptree[i] = i;
            dfs.push(new int[]{-1, i});
        }
        while (!dfs.isEmpty()) {
            int[] edge = dfs.pop();
            int from = edge[0], to = edge[1];
            if (from != -1) {
                union(uptree, from, to);
            }
            if (cross[to] == 0) {
                cross[to] = 1;
                for (int i=0; i<graph.length; i++) {
                    if (graph[to][i] == 1) {
                        dfs.push(new int[]{to, i});
                    }
                }
            }
        }
        int max = 0, max_arg = 0;
        int[] count = new int[graph.length];
        for (int i=0; i<graph.length; i++) {
            int root = find(uptree, i);
            if (uptree[root] >= 0) {
                count[root] ++;
                if (count[root] > max) {
                    max = count[root];
                    max_arg = root;
                }
            }
        }
        return max_arg;
    }

    private int find(int[] uptree, int index) {
        if (uptree[index] < 0) {
            return index;
        }
        if (uptree[index] == index) {
            return index;
        }

        int result = find(uptree, uptree[index]);
        uptree[index] = result;
        return result;
    }

    private void union(int[] uptree, int a, int b) {
        int a_root = find(uptree, a), b_root = find(uptree, b), a_status = uptree[a_root], b_status = uptree[b_root];
        if (a_root == b_root) {
            return;
        }
        if ((a_status >= 0 && b_status >= 0) || a_status == -2 || b_status == -2) {
            // unusable
            uptree[a_root] = -2;
            uptree[b_root] = -2;
        } else if (b_status == -1) {
            uptree[b_root] = a_root;
        } else {
            uptree[a_root] = b_root;
        }
    }
}
